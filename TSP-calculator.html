<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Postal Code Lookup with Distance Matrix and TSP Path</title>
<style>
  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
  }
  th, td {
    border: 1px solid #ccc;
    padding: 8px;
    text-align: center;
  }
  input[type="text"] {
    width: 100%;
    box-sizing: border-box;
  }
  label {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  footer {
    margin-top: 40px;
    font-size: 0.9em;
    color: #555;
  }
</style>
</head>
<body>

<h2>TSP postal codes</h2>

<table id="postalTable">
  <thead>
    <tr>
      <th>Postal Code</th>
      <th>Longitude</th>
      <th>Latitude</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <input type="text" class="postal-input" placeholder="Enter postal code" />
      </td>
      <td>
        <label>
          <input type="checkbox" class="edit-lon" />
          <input type="text" class="lon" readonly />
        </label>
      </td>
      <td>
        <label>
          <input type="checkbox" class="edit-lat" />
          <input type="text" class="lat" readonly />
        </label>
      </td>
    </tr>
  </tbody>
</table>

<h3>Distance Matrix (km)</h3>
<div id="distanceMatrixContainer"></div>

<h3>Optimal Path (TSP Approximation)</h3>
<div id="pathContainer"></div>

<!-- Footer with info -->
<footer>
  <p>&copy; 2025 Jens Hobo. All rights reserved.</p>
  <p>This data is used solely for geographic calculations and visualizations within this application. It is not shared with third parties nor saved on our servers.</p>
</footer>

<script>
const tableBody = document.querySelector('#postalTable tbody');
const distanceContainer = document.getElementById('distanceMatrixContainer');
const pathContainer = document.getElementById('pathContainer');

// Function to add a new blank row at the bottom
function addBlankRow() {
  const row = document.createElement('tr');
  row.innerHTML = `
    <td>
      <input type="text" class="postal-input" placeholder="Enter postal code" />
    </td>
    <td>
      <label>
        <input type="checkbox" class="edit-lon" />
        <input type="text" class="lon" readonly />
      </label>
    </td>
    <td>
      <label>
        <input type="checkbox" class="edit-lat" />
        <input type="text" class="lat" readonly />
      </label>
    </td>
  `;
  tableBody.appendChild(row);
  // Add event listeners
  row.querySelector('.postal-input').addEventListener('input', handlePostalInput);
  row.querySelector('.edit-lon').addEventListener('change', handleLonEditToggle);
  row.querySelector('.edit-lat').addEventListener('change', handleLatEditToggle);
  row.querySelector('.lon').addEventListener('input', handleLonManualEdit);
  row.querySelector('.lat').addEventListener('input', handleLatManualEdit);
}

// Remove extra blank rows, keep only last blank
function cleanBlankRows() {
  const rows = Array.from(tableBody.querySelectorAll('tr'));
  for (let i = 0; i < rows.length - 1; i++) {
    const val = rows[i].querySelector('.postal-input').value.trim();
    if (val === '') {
      tableBody.removeChild(rows[i]);
    }
  }
}

// Compute TSP path (nearest neighbor heuristic)
function computeTSPPath(distMatrix) {
  const n = distMatrix.length;
  if (n === 0) return [];
  const visited = Array(n).fill(false);
  const path = [0];
  visited[0] = true;
  let current = 0;
  while (path.length < n) {
    let nextNode = -1;
    let minDist = Infinity;
    for (let i = 0; i < n; i++) {
      if (!visited[i] && distMatrix[current][i] < minDist) {
        minDist = distMatrix[current][i];
        nextNode = i;
      }
    }
    if (nextNode === -1) break;
    visited[nextNode] = true;
    path.push(nextNode);
    current = nextNode;
  }
  return path;
}

// Get distance matrix
function getDistanceMatrix(locations) {
  const n = locations.length;
  const matrix = Array.from({ length: n }, () => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const dist = haversineDistance(
        locations[i].lat, locations[i].lon,
        locations[j].lat, locations[j].lon
      );
      matrix[i][j] = dist;
      matrix[j][i] = dist;
    }
  }
  return matrix;
}

// Update distance matrix and TSP path
function updateDistanceMatrixAndPath() {
  const rows = Array.from(tableBody.querySelectorAll('tr'));
  const locations = [];
  rows.forEach((row, index) => {
    const lonStr = row.querySelector('.lon').value.trim();
    const latStr = row.querySelector('.lat').value.trim();
    if (lonStr !== '' && latStr !== '') {
      locations.push({ index, lon: parseFloat(lonStr), lat: parseFloat(latStr) });
    }
  });
  if (locations.length === 0) {
    distanceContainer.innerHTML = '<p>No data to display.</p>';
    pathContainer.innerHTML = '';
    return;
  }
  const distMatrix = getDistanceMatrix(locations);
  displayDistanceMatrix(distMatrix, locations);
  displayTSPPath(distMatrix, locations);
}

// Display distance matrix
function displayDistanceMatrix(distMatrix, locations) {
  let html = '<table><thead><tr><th></th>';
  locations.forEach(loc => {
    html += `<th>Row ${loc.index + 1}</th>`;
  });
  html += '</tr></thead><tbody>';
  for (let i = 0; i < locations.length; i++) {
    html += `<tr><th>Row ${locations[i].index + 1}</th>`;
    for (let j = 0; j < locations.length; j++) {
      if (i === j) {
        html += '<td>0</td>';
      } else {
        html += `<td>${distMatrix[i][j].toFixed(2)}</td>`;
      }
    }
    html += '</tr>';
  }
  html += '</tbody></table>';
  distanceContainer.innerHTML = html;
}

// Display TSP path with postal codes
function displayTSPPath(distMatrix, locations) {
  const pathIndices = computeTSPPath(distMatrix);
  const pathPostals = pathIndices.map(i => {
    // Find postal code from the input fields
    const row = document.querySelectorAll('#postalTable tbody tr')[i];
    const postalVal = row.querySelector('.postal-input').value.trim();
    return postalVal !== '' ? postalVal : `Row ${locations[i].index + 1}`;
  });
  const totalDist = pathIndices.reduce((sum, curr, i) => {
    if (i === 0) return 0;
    const prev = pathIndices[i - 1];
    return sum + distMatrix[prev][curr];
  }, 0);
  let html = '<p><strong>Path:</strong> ' + pathPostals.join(' -> ') + '</p>';
  html += `<p><strong>Total Distance:</strong> ${totalDist.toFixed(2)} km</p>`;
  pathContainer.innerHTML = html;
}

// Haversine formula
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // km
  const toRad = Math.PI / 180;
  const dLat = (lat2 - lat1) * toRad;
  const dLon = (lon2 - lon1) * toRad;
  const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
            Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.asin(Math.sqrt(a));
  return R * c;
}

// Handle postal code input
async function handlePostalInput(e) {
  const input = e.target;
  const postalCode = input.value.trim();
  const row = input.closest('tr');
  const lonInput = row.querySelector('.lon');
  const latInput = row.querySelector('.lat');
  const checkLon = row.querySelector('.edit-lon');
  const checkLat = row.querySelector('.edit-lat');

  if (postalCode.length >= 3) {
    try {
      const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(postalCode)}`);
      const data = await response.json();
      if (data && data.length > 0) {
        const place = data[0];
        if (!checkLon.checked) lonInput.value = place.lon;
        if (!checkLat.checked) latInput.value = place.lat;
      } else {
        if (!checkLon.checked) lonInput.value = '';
        if (!checkLat.checked) latInput.value = '';
      }
    } catch (error) {
      console.error('Error fetching geocode:', error);
      if (!checkLon.checked) lonInput.value = '';
      if (!checkLat.checked) latInput.value = '';
    }
  } else {
    if (!checkLon.checked) lonInput.value = '';
    if (!checkLat.checked) latInput.value = '';
  }

  // Clean up extra blank rows and add a new blank if needed
  cleanBlankRows();
  const rows = Array.from(tableBody.querySelectorAll('tr'));
  const lastRow = rows[rows.length - 1];
  const lastInput = lastRow.querySelector('.postal-input');
  if (lastInput.value.trim() !== '') {
    addBlankRow();
  }

  // Update distance matrix and TSP path
  updateDistanceMatrixAndPath();
}

// Handle toggling of longitude edit
function handleLonEditToggle(e) {
  const checkbox = e.target;
  const row = checkbox.closest('tr');
  const lonInput = row.querySelector('.lon');
  if (checkbox.checked) {
    lonInput.readOnly = false;
    lonInput.focus();
  } else {
    lonInput.readOnly = true;
    // Reset to geocode value if available
    handlePostalInput({ target: row.querySelector('.postal-input') });
  }
  // Recalculate path on manual change
  lonInput.addEventListener('input', handleLonManualEdit);
}

// Handle toggling of latitude edit
function handleLatEditToggle(e) {
  const checkbox = e.target;
  const row = checkbox.closest('tr');
  const latInput = row.querySelector('.lat');
  if (checkbox.checked) {
    latInput.readOnly = false;
    latInput.focus();
  } else {
    latInput.readOnly = true;
    // Reset to geocode value if available
    handlePostalInput({ target: row.querySelector('.postal-input') });
  }
  // Recalculate path on manual change
  latInput.addEventListener('input', handleLatManualEdit);
}

// Handle manual longitude edit
function handleLonManualEdit(e) {
  const lonInput = e.target;
  // Trigger path update
  updateDistanceMatrixAndPath();
}

// Handle manual latitude edit
function handleLatManualEdit(e) {
  const latInput = e.target;
  // Trigger path update
  updateDistanceMatrixAndPath();
}

// Initialize first input event
document.querySelector('.postal-input').addEventListener('input', handlePostalInput);

// Add initial blank row
addBlankRow();

</script>
</body>
</html>